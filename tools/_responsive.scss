/* ==========================================================================
tools.responsive
As per: https://web.dev/new-responsive/#conclusion
/ =========================================================================== */

@use 'sass:list';
@use 'sass:math';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:string';
@use '../settings/defaults';
@use './internal' as internal_functions;
@use './rem';

/* --------------------------------------------------------------------------
User preference
/ --------------------------------------------------------------------------- */

/**
 * Mixin: color-scheme
 * A little wrapper that lets you define your dark mode custom
 * properties in a way that supports a toggle component.
 * Usage:
:root {
	// Light theme colors
	--color-slate: #cccccc;

	@include responsive.color-scheme() {
		// Dark theme colors
		--color-slate: #000000;
	}
}
 */
@mixin color-scheme($dark: true, $attribute: data-user-color-scheme) {
	$mode: 'dark';
	@if $dark == true {
		--color-mode: 'light';
	} @else {
		$mode: 'light';

		--color-mode: 'dark';
	}

	@media (prefers-color-scheme: #{$mode}) {
		--color-mode: '#{$mode}';

		&:not([#{$attribute}]) {
			@content;
		}
	}

	&[#{$attribute}='#{$mode}'] {
		@content;
	}
}

/* --------------------------------------------------------------------------
Viewport & formfactor
/ --------------------------------------------------------------------------- */

/**
 * Lock
 * Basic usage:
font-size: responsive.lock(18px, 24px);

// This will scale the property perfectly and smooth from 18px
// on `lap` breakpoint to 24px on `desk` breakpoint.

// You can also redefine the min- and max breakpoints like this:

padding: responsive.lock(18px, 24px, desk, wall);
 */
@function lock($size-min: 16px, $size-max: 20px, $min-bp: lap, $max-bp: desk) {
	$return: $size-min;
	$root-font-size: defaults.$browser-font-size;

	@if map.has-key(defaults.$breakpoints, $min-bp) and
		map.has-key(defaults.$breakpoints, $max-bp)
	{
		@if (math.unit($size-min) == 'px') and
			(math.unit($size-max) == 'px') and
			(math.unit(map.get(defaults.$breakpoints, $min-bp)) == 'px') and
			(math.unit(map.get(defaults.$breakpoints, $max-bp)) == 'px')
		{
			// stylelint-disable-line max-line-length
			$min-bp-value: map.get(defaults.$breakpoints, $min-bp);
			$max-bp-value: map.get(defaults.$breakpoints, $max-bp);

			// Breakpoints
			$min-bp-rem-unitless: internal_functions.strip-units(
				rem.to-rem($min-bp-value, $root-font-size)
			);
			$max-bp-rem-unitless: internal_functions.strip-units(
				rem.to-rem($max-bp-value, $root-font-size)
			);

			// Sizes
			$size-min-rem: rem.to-rem($size-min, $root-font-size);
			$size-min-rem-unitless: internal_functions.strip-units($size-min-rem);
			$size-max-rem: rem.to-rem($size-max, $root-font-size);
			$size-max-rem-unitless: internal_functions.strip-units($size-max-rem);

			// Calculations
			$slope: math.div(
				($size-max-rem-unitless - $size-min-rem-unitless),
				($max-bp-rem-unitless - $min-bp-rem-unitless)
			);
			$y-axis-intersection: (
				(-($min-bp-rem-unitless) * $slope) + $size-min-rem-unitless
			);

			// fill up return
			$return: clamp(
				#{$size-min-rem},
				#{$y-axis-intersection * 1rem} + #{($slope * 100) * 1cqi},
				#{$size-max-rem}
			);
		} @else {
			@error '$size-min, $size-max, $min-bp and $max-bp should be defined in px.';
		}
	} @else {
		@error '`$min-bp: #{$min-bp}` or `$max-bp: #{$max-bp}` should be defined in `defaults.$breakpoints`';
	}

	@return $return;
}
